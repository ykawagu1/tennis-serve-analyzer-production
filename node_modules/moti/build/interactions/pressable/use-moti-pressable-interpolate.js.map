{"version":3,"file":"use-moti-pressable-interpolate.js","sourceRoot":"","sources":["../../../src/interactions/pressable/use-moti-pressable-interpolate.ts"],"names":[],"mappings":"AACA,OAAO,EAAe,eAAe,EAAE,MAAM,yBAAyB,CAAA;AACtE,OAAO,EAA+B,uBAAuB,EAAE,MAAM,WAAW,CAAA;AAChF,OAAO,EAAE,UAAU,EAAE,MAAM,8BAA8B,CAAA;AA+EzD,MAAM,UAAU,2BAA2B,CACzC,WAA+D,EAC/D,kBAA0C,EAC1C,SAAgB;IAEhB,MAAM,OAAO,GAAG,uBAAuB,EAAE,CAAA;IAEzC,MAAM,EAAE,OAAO,EAAE,EAAE,EAAE,IAAI,EAAE,GAAG,UAAU,CACtC,+BAA+B,EAC/B,WAAW,EACX,kBAAkB,EAClB,SAAS,CACV,CAAA;IAED,OAAO,eAAe,CAAQ,GAAG,EAAE;QACjC,OAAO,OAAO,IAAI,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAA;IACzD,CAAC,EAAE,CAAC,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC,EAAE,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,CAAC,CAAA;AAC/C,CAAC","sourcesContent":["import type { MotiPressableInteractionState } from './types'\nimport { SharedValue, useDerivedValue } from 'react-native-reanimated'\nimport { MotiPressableInteractionIds, useMotiPressableContext } from './context'\nimport { useFactory } from './use-validate-factory-or-id'\n\ntype Factory<Props> = (interaction: MotiPressableInteractionState) => Props\ntype Deps = unknown[] | null | undefined\n\n/**\n * `useInterpolateMotiPressable` lets you access the pressable state, and create a reanimated derived value from it.\n *\n * You probably won't need this hook often. `useMotiPressable`, `useMotiPressables`, and `useMotiPressableAnimatedProps` should cover most use-cases\n *\n * Example:\n * ```tsx\n * import { useSharedValue } from 'react-native-reanimated'\n *\n * const mySharedValue = useSharedValue(0)\n * useInterpolateMotiPressable(({ pressed }) => {\n *   'worklet'\n *\n *   mySharedValue.value = pressed ? 1 : 0\n * })\n * ```\n *\n * If you're passing a unique `id` prop to your pressable, you can also isolate this hook to that pressable.\n *\n * Say the parent pressable has `id=\"list\"`, and you want to isolate this hook to the `list` pressable:\n *\n * ```tsx\n * <MotiPressable id=\"menu\">\n *   <Item />\n * </MotiPressable>\n * ```\n *\n * Then, in the `Item` component:\n *\n * ```tsx\n * const mySharedValue = useSharedValue(0)\n * useInterpolateMotiPressable(\"list\", ({ pressed }) => {\n *   'worklet'\n *\n *   mySharedValue.value = pressed ? 1 : 0\n * })\n * ```\n *\n * It returns an `Animated.DerivedValue`. You can also type it with a generic:\n *\n * ```tsx\n * const swipePosition = useSharedValue(0)\n * const state = useInterpolateMotiPressable<{ done: boolean }>(\"list\", ({ pressed }) => {\n *   'worklet'\n *\n *   return {\n *     done: swipePosition.value > 50 && !pressed,\n *   }\n * })\n * ```\n *\n * Just like any derived value, you can read the value it returns with `.value`:\n *\n * ```tsx\n * const state = useInterpolateMotiPressable<{ done: boolean }>(\"list\", ({ pressed }) => {\n *   'worklet'\n *\n *   return {\n *     done: swipePosition.value > 50 && !pressed,\n *   }\n * })\n *\n * // then in some worklet\n * const done = state.value.done\n */\nexport function useInterpolateMotiPressable<Props>(\n  id: MotiPressableInteractionIds['id'],\n  factory: Factory<Props>,\n  deps?: Deps\n): Readonly<SharedValue<Props>>\nexport function useInterpolateMotiPressable<Props>(\n  factory: Factory<Props>,\n  deps?: Deps\n): Readonly<SharedValue<Props>>\nexport function useInterpolateMotiPressable<Props>(\n  factoryOrId: Factory<Props> | MotiPressableInteractionIds['id'],\n  maybeFactoryOrDeps?: Factory<Props> | Deps,\n  maybeDeps?: Deps\n): Readonly<SharedValue<Props>> {\n  const context = useMotiPressableContext()\n\n  const { factory, id, deps } = useFactory<Factory<Props>>(\n    'useMotiPressableAnimatedProps',\n    factoryOrId,\n    maybeFactoryOrDeps,\n    maybeDeps\n  )\n\n  return useDerivedValue<Props>(() => {\n    return context && factory(context.containers[id].value)\n  }, [...(deps || []), context.containers[id]])\n}\n"]}