{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/core/use-dynamic-animation/index.ts"],"names":[],"mappings":"AAKA,OAAO,EAAE,cAAc,EAAE,MAAM,yBAAyB,CAAA;AACxD,OAAO,EAAE,MAAM,EAAE,MAAM,OAAO,CAAA;AAG9B,MAAM,QAAQ,GAAG,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAA;AAE3B;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4BG;AACH,MAAM,CAAC,OAAO,UAAU,mBAAmB,CAGzC,eAAgD,QAAQ;IACxD,MAAM,WAAW,GAAG,MAAM,CAAuC,IAAW,CAAC,CAAA;IAC7E,IAAI,WAAW,CAAC,OAAO,KAAK,IAAI,EAAE,CAAC;QACjC,iDAAiD;QACjD,WAAW,CAAC,OAAO,GAAG,EAAE,KAAK,EAAE,YAAY,EAAE,EAAE,CAAA;IACjD,CAAC;IAED,MAAM,OAAO,GAAG,cAAc,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAAA;IAEzD,MAAM,UAAU,GAAG,MAAM,CAAoC,IAAI,CAAC,CAAA;IAElE,IAAI,UAAU,CAAC,OAAO,IAAI,IAAI,EAAE,CAAC;QAC/B,UAAU,CAAC,OAAO,GAAG;YACnB,OAAO;YACP,aAAa;YACb,IAAI,OAAO;gBACT,OAAO,OAAO,CAAC,KAAK,CAAA;YACtB,CAAC;YACD,SAAS,CAAC,mBAAmB;gBAC3B,SAAS,CAAA;gBAET,MAAM,SAAS,GACb,OAAO,mBAAmB,KAAK,UAAU;oBACvC,CAAC,CAAC,mBAAmB,CAAC,OAAO,CAAC,KAAK,CAAC;oBACpC,CAAC,CAAC,mBAAmB,CAAA;gBAEzB,OAAO,CAAC,KAAK,GAAG,SAAS,CAAA;YAC3B,CAAC;SACF,CAAA;IACH,CAAC;IAED,OAAO,UAAU,CAAC,OAA4C,CAAA;AAChE,CAAC","sourcesContent":["import type {\n  DynamicStyleProp,\n  ExcludeFunctionKeys,\n  UseDynamicAnimationState,\n} from '../types'\nimport { useSharedValue } from 'react-native-reanimated'\nimport { useRef } from 'react'\nimport { ViewStyle, TextStyle, ImageStyle } from 'react-native'\n\nconst fallback = () => ({})\n\n/**\n * A hook that acts like `useAnimationState`, except that it allows for dynamic values rather than static variants.\n *\n * This is useful when you want to update styles on the fly the way you do with `useState`.\n *\n * You can change the state by calling `state.animateTo()`, and access the current state by calling `state.current`.\n *\n * This hook has high performance, triggers no state changes, and runs fully on the native thread!\n *\n * ```js\n * const dynamicAnimation = useDynamicAnimation(() => ({ opacity: 0 }))\n *\n * const onPress = () => {\n *   dynamicAnimation.animateTo({ opacity: 1 })\n * }\n *\n * const onMergeStyle = () => {\n *   // or, merge your styles\n *   // this uses the previous state, like useState from react\n *   dynamicAnimation.animateTo((current) => ({ ...current, scale: 1 }))\n *\n *   // you can also synchronously read the current value\n *   // these two options are the same!\n *   dynamicAnimation.animateTo({ ...dynamicAnimation.current, scale: 1 })\n * }\n * ```\n *\n * @param initialState A function that returns your initial style. Similar to `useState`'s initial style.\n */\nexport default function useDynamicAnimation<\n  _Animate = ViewStyle | TextStyle | ImageStyle,\n  Animate = ExcludeFunctionKeys<_Animate>\n>(initialState: () => DynamicStyleProp<Animate> = fallback) {\n  const initializer = useRef<{ value: DynamicStyleProp<Animate> }>(null as any)\n  if (initializer.current === null) {\n    // use a .value to be certain it's never been set\n    initializer.current = { value: initialState() }\n  }\n\n  const __state = useSharedValue(initializer.current.value)\n\n  const controller = useRef<UseDynamicAnimationState<Animate>>(null)\n\n  if (controller.current == null) {\n    controller.current = {\n      __state,\n      // @ts-ignore\n      get current(): DynamicStyleProp<Animate> {\n        return __state.value\n      },\n      animateTo(nextStateOrFunction) {\n        'worklet'\n\n        const nextStyle =\n          typeof nextStateOrFunction === 'function'\n            ? nextStateOrFunction(__state.value)\n            : nextStateOrFunction\n\n        __state.value = nextStyle\n      },\n    }\n  }\n\n  return controller.current as UseDynamicAnimationState<Animate>\n}\n"]}